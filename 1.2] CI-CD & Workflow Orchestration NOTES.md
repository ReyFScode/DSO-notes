## The What and Why

CI/CD (Continuous Integration and Continuous Delivery/Deployment) is a set of practices that automate and streamline the software development lifecycle. Continuous Integration focuses on merging code changes frequently and verifying them with automated builds and tests, while Continuous Delivery/Deployment ensures that the software can be reliably released at any time. The goal is to improve code quality, reduce manual intervention, and deploy changes faster and more reliably.

Workflow orchestration is a critical component of CI/CD, where tasks, dependencies, environments, and integrations are coordinated to provide an end-to-end automation pipeline from code commit to production deployment.

This guide covers CI/CD implementations using GitHub Actions, GitLab CI/CD, Jenkins, and Azure DevOps Pipelines. It also includes a section on infrastructure automation using CloudFormation.

---

# Provider 1 - GitHub Actions

## Overview

GitHub Actions is a native CI/CD tool provided by GitHub that enables automation of workflows directly within a repository. It uses YAML syntax and supports a wide variety of events and integrations.

##### 1. Workflow Syntax

Workflows are defined in `.github/workflows/*.yml`. They specify when and how pipelines should run.

```yaml
name: My Workflow

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

permissions:
  contents: read

jobs:
  build-job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: update
        run: |
          apt-get update -y
      - name: Test
        run: |
          echo "testing, testing, 123"
```

##### 2. Events

GitHub Actions workflows can be triggered by various events:

- `push` — when code is pushed to the repo
    
- `pull_request` — when a PR is opened or updated
    
- `schedule` — run on a cron schedule
    
- `workflow_dispatch` — manual trigger
    

Use `paths` or `branches` to fine-tune triggers.

##### 3. Jobs and Steps

- **Jobs** run in parallel unless dependencies are specified.
    
- **Steps** are run sequentially within a job.
    

Jobs can share data using artifacts or use the `needs` keyword to specify dependencies.

##### 4. Actions and Marketplace

Actions are reusable functions, either from the community (GitHub Marketplace) or custom-defined. They can simplify logic and standardize repeated functionality like checking out code or setting up environments.

##### 5. Environment Variables

Defined globally, per job, or per step. Use `env:` blocks or access using `${{ env.MY_VAR }}`.

##### 6. Conditional Execution

Use `if:` to control execution of steps or jobs based on expressions, such as branch name or status of previous jobs.

##### 7. Runners

- Hosted runners (`ubuntu-latest`, `windows-latest`)
    
- Self-hosted runners (on-prem, custom labels)
    

##### 8. Secrets and Security

Secrets are stored in the repo/org settings and accessed via `${{ secrets.MY_SECRET }}`. Avoid printing them directly to logs.

##### 9. Artifacts and Caching

Use `actions/upload-artifact` to share files between jobs, or `actions/cache` to speed up workflows by caching dependencies.

##### 10. Dependencies Between Jobs

Use `needs:` to define dependencies and control execution order.


### Example pipeline
```yaml
name: CI Pipeline

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Build step
        run: echo "Building the project..."

  test:
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Test step
        run: echo "Running tests..."

  deploy:
    runs-on: ubuntu-latest
    needs: test
    if: github.ref == 'refs/heads/main'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Deploy step
        run: echo "Deploying the application..."
      - name: Upload artifact
        uses: actions/upload-artifact@v3
        with:
          name: deployment-files
          path: ./path-to-artifacts/
```
- **on**:
    - Triggers the workflow on **push** to the `main` branch.
    - Triggers on **pull requests** targeting `main`.
    - Allows **manual trigger** via the GitHub UI or API (`workflow_dispatch`).
- **jobs**:
    - `build`: Runs first on the latest Ubuntu runner, performs build commands
    - `test`: Runs after `build` completes (`needs: build`), runs tests.
    - `deploy`: Runs after `test` (`needs: test`), only when the branch is `main`.
- **if** condition in `deploy` ensures deployment only runs on `main` branch pushes.
- The deploy job uploads build artifacts using `actions/upload-artifact` for storage and later use.
- Each job includes a `checkout` step to pull the latest code into the runner environment.
- The workflow supports automated and manual invocation for flexibility.




---



# Provider 2 - GitLab CI/CD

## Overview

GitLab CI/CD is tightly integrated with GitLab repositories and offers a robust syntax for defining multi-stage pipelines in a `.gitlab-ci.yml` file. It supports extensive customization with rules, templates, and environments.

### 1. File Structure

```yaml
stages:
  - build
  - test
  - deploy
```

Each stage runs sequentially, and jobs within a stage run in parallel.

### 2. Triggers

GitLab supports event-based execution via:

- `only` and `except`
    
- `rules` (more flexible and preferred)
    

Examples:

```yaml
job_name:
  script: echo "Run on push"
  rules:
    - if: '$CI_PIPELINE_SOURCE == "push"'
      when: always
```

```yaml
job_name:
  script: echo "Merge request triggered"
  only:
    - merge_requests
```

### 3. Jobs and Stages

Jobs are defined under specific stages and execute defined scripts. Images can be specified for isolated environments.

```yaml
build-job:
  stage: build
  script:
    - echo "Build phase"
```

### 4. Artifacts

Used to persist and transfer data between stages:

```yaml
artifacts:
  paths:
    - dist/
```

### 5. Dependencies

Use `needs:` to create job dependencies and allow parallel execution across dependent jobs.

### 6. Variables

Set globally or per job. Available as `$VAR_NAME` in scripts.

```yaml
variables:
  VAR1: "value"
```

### 7. Runners

GitLab supports both shared and custom runners. Self-hosted runners can be tailored to meet performance/security requirements.

### 8. Secrets and Secure Variables

Store secrets in GitLab CI/CD settings. They can be masked and protected to limit access to certain branches.

### 9. Environments and Manual Steps

Define environments for deploy jobs and use `when: manual` for approval gates.

### Example pipeline
```
stages:
  - build
  - test
  - deploy

build-job:
  stage: build
  script:
    - echo "Building the project..."
  rules:
    - if: '$CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_BRANCH == "main"'
      when: always
    - when: never

test-job:
  stage: test
  script:
    - echo "Running tests..."
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      when: always
    - when: never

deploy-job:
  stage: deploy
  script:
    - echo "Deploying the application..."
  rules:
    - if: '$CI_COMMIT_BRANCH == "main" && $CI_PIPELINE_SOURCE == "push"'
      when: manual
    - when: never

```
- **Stages**: Defines three stages — `build`, `test`, and `deploy`.
- **build-job**: Runs automatically on push events to the `main` branch.
- **test-job**: Runs automatically on merge request events (PRs).
- **deploy-job**: Runs on push to main but requires manual approval (`when: manual`).
- Each job uses `rules` exclusively for controlling execution.
- The fallback rule `- when: never` ensures the job doesn’t run unless the conditions match.



---



# Provider 3 - Jenkins

## Overview

Jenkins is a widely used open-source automation server that relies on a master-agent model and Groovy-based `Jenkinsfile` for pipeline-as-code implementation. It is highly extensible via plugins.

### Key Concepts

- **Master/Controller**: Orchestrates pipelines
    
- **Agents/Nodes**: Execute pipeline jobs
    
- **Plugins**: Extend functionality (e.g., Git, Docker, Slack)
    

### Jenkinsfile Example

```groovy
pipeline {
    agent any
    stages {
        stage('Build') {
            steps {
                sh 'make'
            }
        }
        stage('Test') {
            steps {
                sh 'make test'
            }
        }
        stage('Deploy') {
            steps {
                sh './deploy.sh'
            }
        }
    }
}
```

### Features & Tips

- Supports scripted and declarative pipelines
    
- Add `post` blocks for cleanup/notifications
    
- Supports input for manual approvals
    
- Uses credentials store for secret management
    
- Jobs can be parameterized




---


# Provider 4 - Azure DevOps Pipelines

**What is Azure DevOps Pipelines?**
 Azure DevOps Pipelines is a cloud-hosted CI/CD service that automates the building, testing, and deploying of applications across multiple platforms and languages. It supports YAML-based pipeline definitions stored in your repository and integrates tightly with Azure services but also works well with other cloud providers and on-premises environments.

Pipeline Definition and File Location - Pipelines are defined in a YAML file named **`azure-pipelines.yml`** by convention. - This file is typically located at the **root of your repository**. - You can configure Azure DevOps to use pipeline files stored in different locations or use multiple pipeline definitions per project.

#### Core Concepts and Structure
**Triggers** - define when your pipeline runs. You can configure triggers for: - Push events on specific branches. - Pull Requests targeting specific branches. - Scheduled runs using cron expressions. - Manual triggers through the Azure DevOps portal.

Example:
```yaml
trigger:
  branches:
    include:
      - main
      - develop
...
```


**Jobs and Steps** - A **job** is a collection of steps that run sequentially on the same agent. - A **step** is a task or script executed as part of a job. - You can have multiple jobs, which by default run in parallel unless dependencies are specified.

Example with one job and multiple steps:
```yaml
jobs:
- job: BuildAndTest
  pool:
    vmImage: 'ubuntu-latest'
  steps:
  - script: echo "Building project..."
  - script: echo "Running tests..."
```


**Pools and Agents** - Pool specifies the agent pool to run jobs. - You can use Microsoft-hosted agents (pre-configured virtual machines) or self-hosted agents you manage. - Common Microsoft-hosted agent images include `ubuntu-latest`, `windows-latest`, and `macos-latest`.

Example:
```yaml
pool:
  vmImage: 'ubuntu-latest'
```


**Tasks** - Azure DevOps provides many built-in **tasks** for common actions like building code, running tests, publishing artifacts, and deploying. - Tasks can be added declaratively in YAML with configuration inputs. - You can also run arbitrary scripts via the `script` keyword.

Example using a task to publish build artifacts:
```yaml
- task: PublishBuildArtifacts@1
  inputs:
    PathtoPublish: 'dist'
    ArtifactName: 'drop'
    publishLocation: 'Container'
```


**Variables and Secrets** - Variables allow you to parameterize your pipeline and manage values that can change between runs. - They can be defined in YAML or set at pipeline runtime via the UI. - Secrets are securely stored variables that you don’t want exposed in logs or code. - Access variables using the syntax: `$(variableName)`

Example:
```yaml
variables:
  buildConfiguration: 'Release'
  mySecret: $(mySecret)  # Reference secret stored in pipeline settings

steps:
- script: echo "Building in $(buildConfiguration) mode"
```


**Artifact Management** - Artifacts are files or packages produced by your build pipeline, which can be consumed by later stages or downloaded. - Use `PublishBuildArtifacts@1` task to publish artifacts. - Artifacts can be versioned and stored in Azure DevOps or external storage.

Example publishing artifacts:
```yaml
- task: PublishBuildArtifacts@1
  inputs:
    PathtoPublish: 'dist'
    ArtifactName: 'drop'
    publishLocation: 'Container'
```

**Conditional Execution** - You can conditionally run jobs or steps using the `condition:` keyword. - Common conditions include checking branch names, success/failure of previous jobs, or variable values.

Example:

```yaml
- script: echo "Deploying..."
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
```


**Templates and Reuse** - Azure DevOps supports YAML templates to reuse pipeline logic across multiple pipelines. - Templates allow defining common steps or jobs once and referencing them in multiple places, reducing duplication.

Example:
```yaml
# Template file: build-template.yml
parameters:
  buildConfiguration: 'Release'

jobs:
- job: Build
  steps:
  - script: echo "Building with configuration ${{ parameters.buildConfiguration }}"
```

Usage in pipeline:

```yaml
jobs:
- template: build-template.yml
  parameters:
    buildConfiguration: 'Debug'
```


**Deployment and Environments** - Azure DevOps Pipelines integrates with Environments to model target deployment targets (e.g., dev, staging, production). - You can define approvals, checks, and monitor deployments through the Environments UI. - Deployment jobs enable strategies like canary or blue-green deployments.

Example of deployment job:
```yaml
jobs:
- deployment: DeployWeb
  environment: 'production'
  pool:
    vmImage: 'ubuntu-latest'
  strategy:
    runOnce:
      deploy:
        steps:
        - script: echo "Deploying to production"
```

**Manual Intervention and Approvals** - Pipelines can be paused awaiting manual approval via Environments or Approvals and Checks. - Useful for gated releases or sensitive deploys.

Absolutely! Here’s an explanation for the Azure DevOps pipeline example with multiple tasks, manual and automatic triggers, and artifact upload:

```yaml
trigger:
  branches:
    include:
      - main

pr:
  branches:
    include:
      - main

stages:
- stage: Build
  displayName: 'Build Stage'
  jobs:
  - job: BuildJob
    displayName: 'Build Job'
    steps:
    - script: echo "Building the project..."
      displayName: 'Build Step'

- stage: Test
  displayName: 'Test Stage'
  jobs:
  - job: TestJob
    displayName: 'Test Job'
    steps:
    - script: echo "Running tests..."
      displayName: 'Test Step'

- stage: Deploy
  displayName: 'Deploy Stage'
  jobs:
  - job: DeployJob
    displayName: 'Deploy Job'
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
    steps:
    - script: echo "Deploying the application..."
      displayName: 'Deploy Step'
    - publish: $(Build.ArtifactStagingDirectory)
      artifact: drop

# Manual trigger example
resources:
  pipelines:
  - pipeline: manualTrigger
    source: 'your-pipeline-name'
    trigger: none
```
- **trigger**: Automatically runs the pipeline on push events to the `main` branch.
- **pr**: Runs the pipeline on pull requests targeting the `main` branch.
- **stages**: Defines three sequential stages — `Build`, `Test`, and `Deploy`
- **jobs**: Each stage contains a job with named steps performing scripted tasks.
- **condition** on the Deploy job ensures it runs only after successful completion of previous stages and only when the source branch is `main`.
- **publish** step uploads artifacts generated during the pipeline for later use (e.g., deployment or downloads).
- **Manual trigger** can be implemented by disabling automatic triggers (`trigger: none`) on a separate pipeline and starting it manually through the Azure DevOps UI or API.




---
---
# CI/CD Code Comparisons
This section lets you compare raw code for pipelines across each provider to see similarities/differences/and patterns, it also includes the language and location of the file.
### GitHub Actions: 
`.github/workflows/<workflow-name>.yml`
```yaml
name: CI Pipeline

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:  # manual trigger

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Build
        run: |
          mkdir dist
          echo "Build output" > dist/output.txt

  test:
    runs-on: ubuntu-latest
    needs: build
    steps:
      - uses: actions/checkout@v3
      - name: Test
        run: echo "Running tests..."

  deploy:
    runs-on: ubuntu-latest
    needs: test
    steps:
      - uses: actions/checkout@v3
      - name: Upload Artifact
        uses: actions/upload-artifact@v3
        with:
          name: build-artifact
          path: dist/
```
### GitLab CI/CD: 
`.gitlab-ci.yml` (located at the root of the repository)
```yaml
stages:
  - build
  - test
  - deploy

workflow:
  rules:
    - if: '$CI_PIPELINE_SOURCE == "push"'
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_PIPELINE_SOURCE == "web"'

build-job:
  stage: build
  script:
    - mkdir dist
    - echo "Build output" > dist/output.txt
  artifacts:
    paths:
      - dist/

test-job:
  stage: test
  script:
    - echo "Running tests..."

deploy-job:
  stage: deploy
  script:
    - echo "Uploading artifact (simulated)"
  dependencies:
    - build-job
```
### Azure DevOps: 
`azure-pipelines.yml` (located at the root of the repository)
```yaml
trigger:
  branches:
    include:
      - main

pr:
  branches:
    include:
      - main

# Manual trigger enabled via pipeline UI
pool:
  vmImage: 'ubuntu-latest'

steps:
- script: |
    mkdir dist
    echo "Build output" > dist/output.txt
  displayName: 'Build Step'

- script: echo "Running tests..."
  displayName: 'Test Step'

- task: PublishBuildArtifacts@1
  inputs:
    PathtoPublish: 'dist'
    ArtifactName: 'build-artifact'
    publishLocation: 'Container'
  displayName: 'Upload Artifact'
```
### Jenkins: 
`Jenkinsfile` written in groovy (located at the root of the repository)
```groovy
pipeline {
    agent any
    options {
        skipDefaultCheckout(true)
    }
    triggers {
        // To enable on push/PR use GitHub plugin + webhooks
    }
    stages {
        stage('Build') {
            steps {
                sh '''
                mkdir -p dist
                echo "Build output" > dist/output.txt
                '''
            }
        }
        stage('Test') {
            steps {
                sh 'echo "Running tests..."'
            }
        }
        stage('Deploy') {
            steps {
                archiveArtifacts artifacts: 'dist/**', fingerprint: true
            }
        }
    }
}

// To manually trigger: configure Jenkins job to **"Build with Parameters"** or use **no SCM polling**.

```
